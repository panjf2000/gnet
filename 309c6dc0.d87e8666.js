(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{167:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return s}));var a=n(1),i=n(9),r=(n(0),n(280)),o={last_modified_on:"2024-03-04",id:"overview",title:"Overview",description:"High-level description of the gnet framework and its features."},c={id:"about/overview",title:"Overview",description:"High-level description of the gnet framework and its features.",source:"@site/docs/about/overview.md",permalink:"/docs/about/overview",editUrl:"https://github.com/panjf2000/gnet/edit/master/website/docs/about/overview.md",sidebar:"docs",next:{title:"\u9884\u89c8",permalink:"/docs/about/overview-zh"}},l=[{value:"What is gnet?",id:"what-is-gnet",children:[]},{value:"Features",id:"features",children:[]},{value:"Architecture",id:"architecture",children:[{value:"Networking Model of Multiple Threads/Goroutines",id:"networking-model-of-multiple-threadsgoroutines",children:[]}]},{value:"Key designs",id:"key-designs",children:[{value:"Elastic Buffer",id:"elastic-buffer",children:[]}]}],b={rightToc:l};function s(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"what-is-gnet"},"What is gnet?"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"gnet")," is an event-driven networking framework that is ultra-fast and lightweight. It is built from scratch by exploiting ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://man7.org/linux/man-pages/man7/epoll.7.html"}),"epoll")," and ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Kqueue"}),"kqueue")," and it can achieve much higher performance with lower memory consumption than Go ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/net/"}),"net")," in many specific scenarios."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"gnet")," and ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/net/"}),"net")," don't share the same philosophy about network programming. Thus, building network applications with ",Object(r.b)("inlineCode",{parentName:"p"},"gnet")," can be significantly different from building them with ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/net/"}),"net"),", and the philosophies can't be harmonized. There are other similar products written in other programming languages in the community, such as ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/libevent/libevent"}),"libevent"),", ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/libuv/libuv"}),"libuv"),", ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/netty/netty"}),"netty"),", ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/twisted/twisted"}),"twisted"),", ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/tornadoweb/tornado"}),"tornado"),", etc. which work in a similar pattern as ",Object(r.b)("inlineCode",{parentName:"p"},"gnet")," under the hood."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"gnet")," is not designed to displace the Go ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/net/"}),"net"),", but to create an alternative in the Go ecosystem for building performance-sensitive network services. As a result of which, ",Object(r.b)("inlineCode",{parentName:"p"},"gnet")," is not as comprehensive as Go ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/net/"}),"net"),", it provides only the core functionalities (in a concise API set) required by a network application and it is not planned on being a coverall networking framework, as I think ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/net/"}),"net")," has done a good enough job in that area."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"gnet")," sells itself as a high-performance, lightweight, non-blocking, event-driven networking framework written in pure Go which works on the transport layer with TCP/UDP protocols and Unix Domain Socket. It enables developers to implement their own protocols(HTTP, RPC, WebSocket, Redis, etc.) of application layer upon ",Object(r.b)("inlineCode",{parentName:"p"},"gnet")," for building diversified network services. For instance, you get an HTTP Server if you implement HTTP protocol upon ",Object(r.b)("inlineCode",{parentName:"p"},"gnet")," while you have a Redis Server done with the implementation of Redis protocol upon ",Object(r.b)("inlineCode",{parentName:"p"},"gnet")," and so on."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"gnet")," derives from the project: ",Object(r.b)("inlineCode",{parentName:"strong"},"evio")," while having a much higher performance and more features.")),Object(r.b)("h2",{id:"features"},"Features"),Object(r.b)("ul",{className:"contains-task-list"},Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#-performance"}),"High-performance")," event-driven looping based on a networking model of multiple threads/goroutines"),Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Built-in goroutine pool powered by the library ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/panjf2000/ants"}),"ants")),Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Lock-free during the entire runtime"),Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Concise and easy-to-use APIs"),Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Efficient, reusable, and elastic memory buffer: (Elastic-)Ring-Buffer, Linked-List-Buffer and Elastic-Mixed-Buffer"),Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Multiple protocols/IPC mechanisms: ",Object(r.b)("inlineCode",{parentName:"li"},"TCP"),", ",Object(r.b)("inlineCode",{parentName:"li"},"UDP"),", and ",Object(r.b)("inlineCode",{parentName:"li"},"Unix Domain Socket")),Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Multiple load-balancing algorithms: ",Object(r.b)("inlineCode",{parentName:"li"},"Round-Robin"),", ",Object(r.b)("inlineCode",{parentName:"li"},"Source-Addr-Hash"),", and ",Object(r.b)("inlineCode",{parentName:"li"},"Least-Connections")),Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Two event-driven mechanisms: ",Object(r.b)("inlineCode",{parentName:"li"},"epoll")," on ",Object(r.b)("strong",{parentName:"li"},"Linux")," and ",Object(r.b)("inlineCode",{parentName:"li"},"kqueue")," on ",Object(r.b)("strong",{parentName:"li"},"FreeBSD/DragonFly/Darwin")),Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Flexible ticker event"),Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Implementation of ",Object(r.b)("inlineCode",{parentName:"li"},"gnet")," Client"),Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ",Object(r.b)("strong",{parentName:"li"},"Windows")," platform support (For compatibility in development only, do not use it in production)"),Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ","Multiple network addresses binding"),Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ",Object(r.b)("strong",{parentName:"li"},"TLS")," support"),Object(r.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(r.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://kernel.dk/io_uring.pdf"}),"io_uring")," support")),Object(r.b)("h2",{id:"architecture"},"Architecture"),Object(r.b)("h3",{id:"networking-model-of-multiple-threadsgoroutines"},"Networking Model of Multiple Threads/Goroutines"),Object(r.b)("h4",{id:"multiple-reactors"},"Multiple Reactors"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"gnet")," redesigns and implements a new built-in networking model of multiple threads/goroutines: \u300emultiple reactors\u300f which is also the default networking model of multiple threads in ",Object(r.b)("inlineCode",{parentName:"p"},"netty"),", Here's the schematic diagram:"),Object(r.b)("p",{align:"center"},Object(r.b)("img",{alt:"multi_reactor",src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/go/multi-reactors.png"})),Object(r.b)("p",null,"and it works as the following sequence diagram:"),Object(r.b)("p",{align:"center"},Object(r.b)("img",{alt:"reactor",src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/go/multi-reactors-sequence-diagram.png"})),Object(r.b)("h4",{id:"multiple-reactors--goroutine-pool"},"Multiple Reactors + Goroutine Pool"),Object(r.b)("p",null,"You may ask me a question: what if my business logic in ",Object(r.b)("inlineCode",{parentName:"p"},"EventHandler.OnTraffic")," contains some blocking code which leads to blocking in event-loop of ",Object(r.b)("inlineCode",{parentName:"p"},"gnet"),", what is the solution for this kind of situation\uff1f"),Object(r.b)("p",null,"As you know, there is a most important tenet when writing code under ",Object(r.b)("inlineCode",{parentName:"p"},"gnet"),": you should never block the event-loop goroutine in the ",Object(r.b)("inlineCode",{parentName:"p"},"EventHandler.OnTraffic"),", which is also the most important tenet in ",Object(r.b)("inlineCode",{parentName:"p"},"netty"),", otherwise, it will result in a low throughput in your ",Object(r.b)("inlineCode",{parentName:"p"},"gnet")," server."),Object(r.b)("p",null,"And the solution to that could be found in the subsequent networking model of multiple threads/goroutines in ",Object(r.b)("inlineCode",{parentName:"p"},"gnet"),": \u300emultiple reactors with thread/goroutine pool\u300fwhich pulls you out from the blocking mire, it will construct a worker-pool with fixed capacity and put those blocking jobs in ",Object(r.b)("inlineCode",{parentName:"p"},"EventHandler.OnTraffic")," into the worker-pool to make the event-loop goroutines non-blocking."),Object(r.b)("p",null,"The networking model:\u300emultiple reactors with thread/goroutine pool\u300fdissolves the blocking jobs by introducing a goroutine pool, as shown below:"),Object(r.b)("p",{align:"center"},Object(r.b)("img",{alt:"multi_reactor_thread_pool",src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/go/multi-reactors%2Bthread-pool.png"})),Object(r.b)("p",null,"and it works as the following sequence diagram:"),Object(r.b)("p",{align:"center"},Object(r.b)("img",{alt:"multi-reactors",src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/go/multi-reactors%2Bthread-pool-sequence-diagram.png"})),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"gnet")," implements the networking model:\u300emultiple reactors with thread/goroutine pool\u300fby the aid of a high-performance goroutine pool called ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/panjf2000/ants"}),"ants")," that allows you to manage and recycle a massive number of goroutines in your concurrent programs, the full features and usages in ",Object(r.b)("inlineCode",{parentName:"p"},"ants")," are documented ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://pkg.go.dev/github.com/panjf2000/ants/v2?tab=doc"}),"here"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"gnet")," integrates ",Object(r.b)("inlineCode",{parentName:"p"},"ants")," and provides the ",Object(r.b)("inlineCode",{parentName:"p"},"pool.goroutine.Default()")," method that you can call to instantiate a ",Object(r.b)("inlineCode",{parentName:"p"},"ants")," pool where you are able to put your blocking code logic and call the function ",Object(r.b)("inlineCode",{parentName:"p"},"gnet.Conn.AsyncWrite([]byte)")," to send out data asynchronously after you finish the blocking process and get the output data, which makes the goroutine of event-loop non-blocking."),Object(r.b)("p",null,"The details about integrating ",Object(r.b)("inlineCode",{parentName:"p"},"gnet"),"  with ",Object(r.b)("inlineCode",{parentName:"p"},"ants")," are shown ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#echo-server-with-blocking-logic"}),"here"),"."),Object(r.b)("h2",{id:"key-designs"},"Key designs"),Object(r.b)("h3",{id:"elastic-buffer"},"Elastic Buffer"),Object(r.b)("h4",{id:"elastic-ring-buffer"},"Elastic Ring Buffer"),Object(r.b)("p",{align:"center"},Object(r.b)("img",{src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/go/ring-buffer.gif"})),Object(r.b)("h4",{id:"elastic-ring--linked-list-buffer"},"Elastic Ring & Linked-list Buffer"),Object(r.b)("p",{align:"center"},Object(r.b)("img",{src:"https://res.strikefreedom.top/static_res/blog/figures/elastic-buffer.png"})),Object(r.b)("p",null,"There are two buffers inside ",Object(r.b)("inlineCode",{parentName:"p"},"gnet"),": inbound buffer (elastic-ring-buffer) and outbound buffer (elastic-ring&linked-list-buffer) to buffer and manage inbound/outbound network data, inbound and outbound buffers inside gnet are designed and tuned to reuse memory and be auto-scaling on demand."),Object(r.b)("p",null,"The purpose of implementing inbound and outbound buffers in ",Object(r.b)("inlineCode",{parentName:"p"},"gnet")," is to transfer the logic of buffering and managing network data based on application protocol upon TCP stream from business server to framework and unify the network data buffer, which minimizes the complexity of business code so that developers are able to concentrate on business logic instead of the underlying implementation."))}s.isMDXComponent=!0},280:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var b=i.a.createContext({}),s=function(e){var t=i.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):c({},t,{},e)),n},p=function(e){var t=s(e.components);return i.a.createElement(b.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,b=l(e,["components","mdxType","originalType","parentName"]),p=s(n),d=a,m=p["".concat(o,".").concat(d)]||p[d]||u[d]||r;return n?i.a.createElement(m,c({ref:t},b,{components:n})):i.a.createElement(m,c({ref:t},b))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var b=2;b<r;b++)o[b]=n[b];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);